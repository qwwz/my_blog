(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{248:function(t,_,e){"use strict";e.r(_);var s=e(0),i=Object(s.a)({},function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),e("p",[t._v("因为你考虑掉了另外一些复杂的场景，比如3D动画如何呈现出变换效果，当元素含有层叠上下文时如何控制显示和隐藏等等。")]),t._v(" "),t._m(6),t._v(" "),e("p",[t._v("那这棵图层树是根据什么来构建的呢？")]),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),e("p",[t._v("层叠上下文也基本上是有一些特定的CSS属性创建的，一般有以下情况:")]),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),e("p",[t._v("比如一个div，你只给他设置 100 * 100 像素的大小，而你在里面放了非常多的文字，那么超出的文字部分就需要被剪裁。当然如果出现了滚动条，那么滚动条会被单独提升为一个图层。")]),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),e("p",[t._v("这个隐式合成其实隐藏着巨大的风险，如果在一个大型应用中，当一个"),e("code",[t._v("z-index")]),t._v("比较低的元素被提升为单独图层之后，层叠在它上面的的元素统统都会被提升为单独的图层，可能会增加上千个图层，大大增加内存的压力，甚至直接让页面崩溃。这就是"),e("strong",[t._v("层爆炸")]),t._v("的原理。这里有一个具体的例子，"),e("a",{attrs:{href:"https://segmentfault.com/a/1190000014520786",target:"_blank",rel:"noopener noreferrer"}},[t._v("点击打开"),e("OutboundLink")],1),t._v("。")]),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),e("p",[t._v("接下来渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框......然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划。")]),t._v(" "),t._m(18),t._v(" "),e("p",[e("img",{attrs:{src:t.$withBase("/week10/1.jpg"),alt:"project"}})]),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),t._m(28),t._v(" "),t._m(29),t._v(" "),t._m(30),t._v(" "),e("p",[t._v("看到这里你也就是明白，当某个动画大量占用内存的时候，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象。")]),t._v(" "),t._m(31),t._v(" "),e("p",[t._v("到这里，我们算是把整个过程给走通了，现在重新来梳理一下页面渲染的流程。")]),t._v(" "),e("p",[e("img",{attrs:{src:t.$withBase("/week10/4.jpg"),alt:"project"}})])])},[function(){var t=this.$createElement,_=this._self._c||t;return _("h1",{attrs:{id:"_003-说一说从输入url到页面呈现发生了什么？——渲染过程篇"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_003-说一说从输入url到页面呈现发生了什么？——渲染过程篇","aria-hidden":"true"}},[this._v("#")]),this._v(" 003: 说一说从输入URL到页面呈现发生了什么？——渲染过程篇")])},function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("p",[t._v("上一节介绍了浏览器"),e("code",[t._v("解析")]),t._v("的过程,其中包含"),e("code",[t._v("构建DOM")]),t._v("、"),e("code",[t._v("样式计算")]),t._v("和"),e("code",[t._v("构建布局树")]),t._v("。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("接下来就来拆解下一个过程——"),_("code",[this._v("渲染")]),this._v("。分为以下几个步骤:")])},function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("ul",[e("li",[t._v("建立"),e("code",[t._v("图层树")]),t._v("("),e("code",[t._v("Layer Tree")]),t._v(")")]),t._v(" "),e("li",[t._v("生成"),e("code",[t._v("绘制列表")])]),t._v(" "),e("li",[t._v("生成"),e("code",[t._v("图块")]),t._v("并"),e("code",[t._v("栅格化")])]),t._v(" "),e("li",[t._v("显示器显示内容")])])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"一、建图层树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、建图层树","aria-hidden":"true"}},[this._v("#")]),this._v(" 一、建图层树")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("如果你觉得现在"),_("code",[this._v("DOM节点")]),this._v("也有了，样式和位置信息也都有了，可以开始绘制页面了，那你就错了。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("为了解决如上所述的问题，浏览器在构建完"),_("code",[this._v("布局树")]),this._v("之后，还会对特定的节点进行分层，构建一棵"),_("code",[this._v("图层树")]),this._v("("),_("code",[this._v("Layer Tree")]),this._v(")。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("一般情况下，节点的图层会默认属于父亲节点的图层(这些图层也称为"),_("strong",[this._v("合成层")]),this._v(")。那什么时候会提升为一个单独的合成层呢？")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("有两种情况需要分别讨论，一种是"),_("strong",[this._v("显式合成")]),this._v("，一种是"),_("strong",[this._v("隐式合成")]),this._v("。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h3",{attrs:{id:"显式合成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#显式合成","aria-hidden":"true"}},[this._v("#")]),this._v(" 显式合成")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("下面是"),_("code",[this._v("显式合成")]),this._v("的情况:")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("一、 拥有"),_("strong",[this._v("层叠上下文")]),this._v("的节点。")])},function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("ol",[e("li",[t._v("HTML根元素本身就具有层叠上下文。")]),t._v(" "),e("li",[t._v("普通元素设置"),e("strong",[t._v("position不为static")]),t._v("并且"),e("strong",[t._v("设置了z-index属性")]),t._v("，会产生层叠上下文。")]),t._v(" "),e("li",[t._v("元素的 "),e("strong",[t._v("opacity")]),t._v(" 值不是 1")]),t._v(" "),e("li",[t._v("元素的 "),e("strong",[t._v("transform")]),t._v(" 值不是 none")]),t._v(" "),e("li",[t._v("元素的 "),e("strong",[t._v("filter")]),t._v(" 值不是 none")]),t._v(" "),e("li",[t._v("元素的 "),e("strong",[t._v("isolation")]),t._v(" 值是isolate")]),t._v(" "),e("li",[e("strong",[t._v("will-change")]),t._v("指定的属性值为上面任意一个。(will-change的作用后面会详细介绍)")])])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("二、需要"),_("strong",[this._v("剪裁")]),this._v("的地方。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h3",{attrs:{id:"隐式合成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#隐式合成","aria-hidden":"true"}},[this._v("#")]),this._v(" 隐式合成")])},function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("p",[t._v("接下来是"),e("code",[t._v("隐式合成")]),t._v("，简单来说就是"),e("code",[t._v("层叠等级低")]),t._v("的节点被提升为单独的图层之后，那么"),e("code",[t._v("所有层叠等级比它高")]),t._v("的节点"),e("strong",[t._v("都会")]),t._v("成为一个单独的图层。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("值得注意的是，当需要"),_("code",[this._v("repaint")]),this._v("时，只需要"),_("code",[this._v("repaint")]),this._v("本身，而不会影响到其他的层。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"二、生成绘制列表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、生成绘制列表","aria-hidden":"true"}},[this._v("#")]),this._v(" 二、生成绘制列表")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("这里我以百度首页为例，大家可以在 Chrome 开发者工具中在设置栏中展开 "),_("code",[this._v("more tools")]),this._v(", 然后选择"),_("code",[this._v("Layers")]),this._v("面板，就能看到下面的绘制列表:")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"三、生成图块和生成位图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、生成图块和生成位图","aria-hidden":"true"}},[this._v("#")]),this._v(" 三、生成图块和生成位图")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("现在开始绘制操作，实际上在渲染进程中绘制操作是由专门的线程来完成的，这个线程叫"),_("strong",[this._v("合成线程")]),this._v("。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("绘制列表准备好了之后，渲染进程的主线程会给"),_("code",[this._v("合成线程")]),this._v("发送"),_("code",[this._v("commit")]),this._v("消息，把绘制列表提交给合成线程。接下来就是合成线程一展宏图的时候啦。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("首先，考虑到视口就这么大，当页面非常大的时候，要滑很长时间才能滑到底，如果要一口气全部绘制出来是相当浪费性能的。因此，合成线程要做的第一件事情就是将图层"),_("strong",[this._v("分块")]),this._v("。这些块的大小一般不会特别大，通常是 256 * 256 或者 512 * 512 这个规格。这样可以大大加速页面的首屏展示。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("因为后面图块数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间。针对这个问题，Chrome 采用了一个策略: 在首次合成图块时只采用一个"),_("strong",[this._v("低分辨率")]),this._v("的图片，这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换。这也是 Chrome 底层优化首屏加载速度的一个手段。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("顺便提醒一点，渲染进程中专门维护了一个"),_("strong",[this._v("栅格化线程池")]),this._v("，专门负责把"),_("strong",[this._v("图块")]),this._v("转换为"),_("strong",[this._v("位图数据")]),this._v("。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("然后合成线程会选择视口附近的"),_("strong",[this._v("图块")]),this._v("，把它交给"),_("strong",[this._v("栅格化线程池")]),this._v("生成位图。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给"),_("code",[this._v("合成线程")]),this._v("。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"四、显示器显示内容"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、显示器显示内容","aria-hidden":"true"}},[this._v("#")]),this._v(" 四、显示器显示内容")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("栅格化操作完成后，"),_("strong",[this._v("合成线程")]),this._v('会生成一个绘制命令，即"DrawQuad"，并发送给浏览器进程。')])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("浏览器进程中的"),_("code",[this._v("viz组件")]),this._v("接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡。为什么发给显卡呢？我想有必要先聊一聊显示器显示图像的原理。")])},function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("p",[t._v("无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的"),e("strong",[t._v("前缓冲区")]),t._v("。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到"),e("strong",[t._v("后缓冲区")]),t._v("，然后系统自动将"),e("code",[t._v("前缓冲区")]),t._v("和"),e("code",[t._v("后缓冲区")]),t._v("对换位置，如此循环更新。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[this._v("#")]),this._v(" 总结")])}],!1,null,null,null);_.default=i.exports}}]);