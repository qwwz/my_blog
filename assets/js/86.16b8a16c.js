(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{244:function(t,_,v){"use strict";v.r(_);var e=v(0),s=Object(e.a)({},function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._m(3),t._v(" "),v("p",[t._v("那么这些字段都是干嘛的呢？它们用来解决那些问题？")]),t._v(" "),v("p",[t._v("接下来我们就来一一梳理，TCP 的时间戳主要解决两大问题:")]),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),v("p",[t._v("在没有时间戳的时候，计算 RTT 会遇到的问题如下图所示:")]),t._v(" "),v("p",[v("img",{attrs:{src:t.$withBase("/tcp/008.jpg")}})]),t._v(" "),v("p",[t._v("如果以第一次发包为开始时间的话，就会出现左图的问题，RTT 明显偏大，开始时间应该采用第二次的；")]),t._v(" "),v("p",[t._v("如果以第二次发包为开始时间的话，就会导致右图的问题，RTT 明显偏小，开始时间应该采用第一次发包的。")]),t._v(" "),v("p",[t._v("实际上无论开始时间以第一次发包还是第二次发包为准，都是不准确的。")]),t._v(" "),v("p",[t._v("那这个时候引入时间戳就很好的解决了这个问题。")]),t._v(" "),v("p",[t._v("比如现在 a 向 b 发送一个报文 s1，b 向 a 回复一个含 ACK 的报文 s2 那么：")]),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),v("p",[t._v("现在我们来模拟一下这个问题。")]),t._v(" "),v("p",[t._v("序列号的范围其实是在0 ~ 2 ^ 32 - 1, 为了方便演示，我们缩小一下这个区间，假设范围是 0 ~ 4，那么到达 4 的时候会回到 0。")]),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),v("p",[t._v("那么用 timestamp 就能很好地解决这个问题，因为每次发包的时候都是将发包机器当时的内核时间记录在报文中，那么两次发包序列号即使相同，时间戳也不可能相同，这样就能够区分开两个数据包了。")])])},[function(){var t=this.$createElement,_=this._self._c||t;return _("h1",{attrs:{id:"_007-能不能说说tcp报文中时间戳的作用？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_007-能不能说说tcp报文中时间戳的作用？","aria-hidden":"true"}},[this._v("#")]),this._v(" 007: 能不能说说TCP报文中时间戳的作用？")])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[_("code",[this._v("timestamp")]),this._v("是 TCP 报文首部的一个可选项，一共占 10 个字节，格式如下:")])},function(){var t=this.$createElement,_=this._self._c||t;return _("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[this._v("kind(1 字节) + length(1 字节) + info(8 个字节)\n")])])])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("其中 kind = 8， length = 10， info 有两部分构成: "),_("strong",[this._v("timestamp")]),this._v("和"),_("strong",[this._v("timestamp echo")]),this._v("，各占 4 个字节。")])},function(){var t=this.$createElement,_=this._self._c||t;return _("ul",[_("li",[this._v("计算往返时延 RTT(Round-Trip Time)")]),this._v(" "),_("li",[this._v("防止序列号的回绕问题")])])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"计算往返时延-rtt"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算往返时延-rtt","aria-hidden":"true"}},[this._v("#")]),this._v(" 计算往返时延 RTT")])},function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ul",[v("li",[v("strong",[t._v("step 1:")]),t._v(" a 向 b 发送的时候，"),v("code",[t._v("timestamp")]),t._v(" 中存放的内容就是 a 主机发送时的内核时刻 "),v("code",[t._v("ta1")]),t._v("。")]),t._v(" "),v("li",[v("strong",[t._v("step 2:")]),t._v(" b 向 a 回复 s2 报文的时候，"),v("code",[t._v("timestamp")]),t._v(" 中存放的是 b 主机的时刻 "),v("code",[t._v("tb")]),t._v(", "),v("code",[t._v("timestamp echo")]),t._v("字段为从 s1 报文中解析出来的 ta1。")]),t._v(" "),v("li",[v("strong",[t._v("step 3:")]),t._v(" a 收到 b 的 s2 报文之后，此时 a 主机的内核时刻是 ta2, 而在 s2 报文中的 timestamp echo 选项中可以得到 "),v("code",[t._v("ta1")]),t._v(", 也就是 s2 对应的报文最初的发送时刻。然后直接采用 ta2 - ta1 就得到了 RTT 的值。")])])},function(){var t=this.$createElement,_=this._self._c||t;return _("h2",{attrs:{id:"防止序列号回绕问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#防止序列号回绕问题","aria-hidden":"true"}},[this._v("#")]),this._v(" 防止序列号回绕问题")])},function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("table",[v("thead",[v("tr",[v("th",[t._v("第几次发包")]),t._v(" "),v("th",[t._v("发送字节")]),t._v(" "),v("th",[t._v("对应序列号")]),t._v(" "),v("th",[t._v("状态")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("1")]),t._v(" "),v("td",[t._v("0 ~ 1")]),t._v(" "),v("td",[t._v("0 ~ 1")]),t._v(" "),v("td",[t._v("成功接收")])]),t._v(" "),v("tr",[v("td",[t._v("2")]),t._v(" "),v("td",[t._v("1 ~ 2")]),t._v(" "),v("td",[t._v("1 ~ 2")]),t._v(" "),v("td",[t._v("滞留在网络中")])]),t._v(" "),v("tr",[v("td",[t._v("3")]),t._v(" "),v("td",[t._v("2 ~ 3")]),t._v(" "),v("td",[t._v("2 ~ 3")]),t._v(" "),v("td",[t._v("成功接收")])]),t._v(" "),v("tr",[v("td",[t._v("4")]),t._v(" "),v("td",[t._v("3 ~ 4")]),t._v(" "),v("td",[t._v("3 ~ 4")]),t._v(" "),v("td",[t._v("成功接收")])]),t._v(" "),v("tr",[v("td",[t._v("5")]),t._v(" "),v("td",[t._v("4 ~ 5")]),t._v(" "),v("td",[t._v("0 ~ 1")]),t._v(" "),v("td",[t._v("成功接收，序列号从0开始")])]),t._v(" "),v("tr",[v("td",[t._v("6")]),t._v(" "),v("td",[t._v("5 ~ 6")]),t._v(" "),v("td",[t._v("1 ~ 2")]),t._v(" "),v("td",[t._v("？？？")])])])])},function(){var t=this.$createElement,_=this._self._c||t;return _("p",[this._v("假设在第 6 次的时候，之前还滞留在网路中的包回来了，那么就有两个序列号为"),_("code",[this._v("1 ~ 2")]),this._v("的数据包了，怎么区分谁是谁呢？这个时候就产生了序列号回绕的问题。")])}],!1,null,null,null);_.default=s.exports}}]);